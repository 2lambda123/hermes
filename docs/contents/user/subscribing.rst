Subscribing
===========
Core concept behind using push model in Hermes project is that it makes consuming events rather simple.
You only need to create endpoint that will accept published messages e.g.:

::

 http://service.example.com/foobar/events

Hermes by default will use POST to deliver events over http but keep in mind that
this behaviour depends on how customized version of sender you are running.

Be aware, that before message consumption subscription needs to be defined.
See :doc:`console` for details on how to use console to create subscription.

Transport over HTTP
-------------------

Request format
^^^^^^^^^^^^^^
Generally speaking your service should be ready to accept POST requests on specified endpoint. Sample request:

::

 POST /foobar/events HTTP/1.1
 Accept-Encoding: gzip
 Keep-Alive: true
 Hermes-Message-Id: 282406c63512e693e940b0b212f76dd1
 Content-Type: application/json
 Host: service.example.com
 User-Agent: Jetty/9.1.1.v20140108
 Content-Length: 14

 {"foo": "bar"}

Message Id
^^^^^^^^^^

Request will contain special header: ``Hermes-Message-Id``. This is event UUID generated by Hermes, which can be
used to track system-wide event flow.

Response codes
^^^^^^^^^^^^^^

Hermes will treat message as delivered if subscriber responded with status code from **2xx** family.

Everything else (especially **4xx** and **5xx** family) will be cached and resent until message TTL expires.
This behaviour can be configured using **retryClientErrors** flag. If you decide not to retry client errors then
hermes will only retry for 5xx family.

Message delivery
----------------

Rate limiting
^^^^^^^^^^^^^

Hermes is delivering messages to subscribers with **configurable rate** (number of events per second).
This prevents temporary event bursts on topics to be propagated to every service that is subscribing.
Hermes is ready for high load but subscribers don't have to. They can specify how much events per second
they can handle and message delivery will flatten out to such velocity. However if hermes can detect that
subscription endpoint still can't handle such a load, rate will be **dynamically adjusted** to maximum value for
which hermes does not receive errors from subscriber.

Message TTL
^^^^^^^^^^^

Every message sent to subscriber has its own **configurable TTL** (time-to-live) which determines for how long it
will be kept in memory and resent before discarding in case of problems with delivery. This gives some time for
subscriber to reboot or spawn new cloud machines and no events will be lost. Keep in mind that in case of errors
hermes will use rate limiting to not send more events that subscriber can handle.
